# ========================================
# Azure DevOps Pipeline - Production
# ========================================

trigger:
  branches:
    include:
      - main

pr: none

variables:
  - group: production-secrets  # Groupe de variables dans Azure DevOps
  - name: registry
    value: 'yourregistry.azurecr.io'
  - name: imageNameWeb
    value: 'weatherforecast-web'
  - name: imageNameApi
    value: 'weatherforecast-api'

stages:
  # ========================================
  # Stage 1 : G√©n√©rer le Certificat
  # ========================================
  - stage: Certificate
    displayName: 'Setup Certificate'
    jobs:
      - job: GenerateCertificate
        displayName: 'Generate or Restore Certificate'
        pool:
          vmImage: 'windows-latest'
        
        steps:
          - checkout: self
          
          # Option A : G√©n√©rer un nouveau certificat
          - task: PowerShell@2
            displayName: 'Generate Certificate'
            condition: eq(variables['CERTIFICATE_EXISTS'], 'false')
            env:
              CERTIFICATE_PASSWORD: $(CertificatePassword)
            inputs:
              targetType: 'filePath'
              filePath: '$(Build.SourcesDirectory)/scripts/generate-certificate.ps1'
              arguments: '-OutputPath "$(Build.ArtifactStagingDirectory)/certificates"'
              pwsh: true
            name: GenerateCert
          
          # Option B : Restaurer depuis Azure Key Vault
          - task: AzureKeyVault@2
            displayName: 'Get Certificate from Key Vault'
            condition: eq(variables['CERTIFICATE_EXISTS'], 'true')
            inputs:
              azureSubscription: 'Azure Subscription'
              KeyVaultName: 'weatherforecast-kv'
              SecretsFilter: 'dataprotection-cert-pfx,dataprotection-cert-thumbprint'
              RunAsPreJob: false
          
          - task: PowerShell@2
            displayName: 'Restore Certificate from Key Vault'
            condition: eq(variables['CERTIFICATE_EXISTS'], 'true')
            inputs:
              targetType: 'inline'
              script: |
                $pfxBytes = [Convert]::FromBase64String("$(dataprotection-cert-pfx)")
                $pfxPath = "$(Build.ArtifactStagingDirectory)/certificates/weatherforecast-dataprotection.pfx"
                New-Item -ItemType Directory -Path "$(Build.ArtifactStagingDirectory)/certificates" -Force
                [IO.File]::WriteAllBytes($pfxPath, $pfxBytes)
                
                "$(dataprotection-cert-thumbprint)" | Out-File "$(Build.ArtifactStagingDirectory)/certificates/thumbprint.txt"
                
                Write-Host "##vso[task.setvariable variable=CERTIFICATE_THUMBPRINT;isOutput=true]$(dataprotection-cert-thumbprint)"
          
          # Publier le certificat comme artifact
          - task: PublishPipelineArtifact@1
            displayName: 'Publish Certificate'
            inputs:
              targetPath: '$(Build.ArtifactStagingDirectory)/certificates'
              artifact: 'certificate'
              publishLocation: 'pipeline'

  # ========================================
  # Stage 2 : Build des Images Docker
  # ========================================
  - stage: Build
    displayName: 'Build Docker Images'
    dependsOn: Certificate
    jobs:
      - job: BuildWeb
        displayName: 'Build Web Application'
        pool:
          vmImage: 'ubuntu-latest'
        steps:
          - checkout: self
          
          - task: Docker@2
            displayName: 'Build Web Image'
            inputs:
              containerRegistry: 'Azure Container Registry'
              repository: $(imageNameWeb)
              command: 'buildAndPush'
              Dockerfile: 'application/Dockerfile'
              tags: |
                $(Build.BuildId)
                latest
      
      - job: BuildApi
        displayName: 'Build API'
        pool:
          vmImage: 'ubuntu-latest'
        steps:
          - checkout: self
          
          - task: Docker@2
            displayName: 'Build API Image'
            inputs:
              containerRegistry: 'Azure Container Registry'
              repository: $(imageNameApi)
              command: 'buildAndPush'
              Dockerfile: 'api/Dockerfile'
              tags: |
                $(Build.BuildId)
                latest

  # ========================================
  # Stage 3 : D√©ploiement Production
  # ========================================
  - stage: Deploy
    displayName: 'Deploy to Production'
    dependsOn: Build
    condition: succeeded()
    jobs:
      - deployment: DeployProduction
        displayName: 'Deploy to Production Server'
        pool:
          vmImage: 'ubuntu-latest'
        environment: 'production'
        strategy:
          runOnce:
            deploy:
              steps:
                - checkout: self
                
                - task: DownloadPipelineArtifact@2
                  displayName: 'Download Certificate'
                  inputs:
                    buildType: 'current'
                    artifactName: 'certificate'
                    targetPath: '$(Pipeline.Workspace)/certificates'
                
                # Copier les fichiers sur le serveur
                - task: CopyFilesOverSSH@0
                  displayName: 'Copy Files to Server'
                  inputs:
                    sshEndpoint: 'Production Server'
                    sourceFolder: '$(Build.SourcesDirectory)'
                    contents: |
                      docker-compose.yml
                      .env.example
                    targetFolder: '/opt/weatherforecast/'
                
                - task: CopyFilesOverSSH@0
                  displayName: 'Copy Certificate to Server'
                  inputs:
                    sshEndpoint: 'Production Server'
                    sourceFolder: '$(Pipeline.Workspace)/certificates'
                    contents: '**'
                    targetFolder: '/opt/weatherforecast/certificates'
                
                # D√©ployer via SSH
                - task: SSH@0
                  displayName: 'Deploy Application'
                  inputs:
                    sshEndpoint: 'Production Server'
                    runOptions: 'inline'
                    inline: |
                      cd /opt/weatherforecast
                      
                      # Lire le thumbprint
                      THUMBPRINT=$(cat certificates/thumbprint.txt)
                      
                      # Cr√©er le fichier .env
                      cat > .env <<EOF
                      ASPNETCORE_ENVIRONMENT=Production
                      POSTGRES_PASSWORD=$(PostgresPassword)
                      DATAPROTECTION_CERTIFICATE_THUMBPRINT=$THUMBPRINT
                      JWT_SECRET=$(JwtSecret)
                      EOF
                      
                      # Copier le certificat dans le volume Docker
                      docker volume create certificates
                      docker run --rm -v certificates:/certs -v $(pwd)/certificates:/source alpine \
                        cp /source/weatherforecast-dataprotection.pfx /certs/
                      
                      # Pull les images
                      docker-compose pull
                      
                      # D√©marrer PostgreSQL d'abord
                      docker-compose up -d postgres
                      
                      # Attendre PostgreSQL
                      echo "‚è≥ Attente de PostgreSQL..."
                      for i in {1..30}; do
                        if docker exec weatherforecast-db pg_isready -U weatheruser >/dev/null 2>&1; then
                          echo "‚úÖ PostgreSQL pr√™t"
                          break
                        fi
                        sleep 2
                      done
                      
                      # Appliquer les migrations
                      echo "üîÑ Application des migrations..."
                      docker-compose run --rm \
                        -e ConnectionStrings__DefaultConnection="Host=postgres;Database=weatherforecastdb;Username=weatheruser;Password=$(PostgresPassword)" \
                        web dotnet ef database update --project /src/infra --startup-project /src/application
                      
                      if [ $? -eq 0 ]; then
                        echo "‚úÖ Migrations appliqu√©es"
                      else
                        echo "‚ùå √âchec des migrations"
                        exit 1
                      fi
                      
                      # D√©marrer tous les services
                      docker-compose up -d
                      
                      echo "‚úÖ D√©ploiement termin√©"
                      docker-compose ps
                
                # Health Check
                - task: PowerShell@2
                  displayName: 'Health Check'
                  inputs:
                    targetType: 'inline'
                    script: |
                      Start-Sleep -Seconds 10
                      
                      $webHealth = Invoke-WebRequest -Uri "https://weatherforecast.yourdomain.com/health" -UseBasicParsing
                      if ($webHealth.StatusCode -ne 200) {
                        Write-Error "‚ùå Web health check failed"
                        exit 1
                      }
                      
                      $apiHealth = Invoke-WebRequest -Uri "https://api.weatherforecast.yourdomain.com/health" -UseBasicParsing
                      if ($apiHealth.StatusCode -ne 200) {
                        Write-Error "‚ùå API health check failed"
                        exit 1
                      }
                      
                      Write-Host "‚úÖ Health checks passed"

  # ========================================
  # Stage 4 : Backup du Certificat (Optionnel)
  # ========================================
  - stage: Backup
    displayName: 'Backup Certificate to Key Vault'
    dependsOn: Deploy
    condition: and(succeeded(), eq(variables['CERTIFICATE_EXISTS'], 'false'))
    jobs:
      - job: BackupToKeyVault
        displayName: 'Backup to Azure Key Vault'
        pool:
          vmImage: 'ubuntu-latest'
        steps:
          - task: DownloadPipelineArtifact@2
            displayName: 'Download Certificate'
            inputs:
              buildType: 'current'
              artifactName: 'certificate'
              targetPath: '$(Pipeline.Workspace)/certificates'
          
          - task: AzureCLI@2
            displayName: 'Upload to Key Vault'
            inputs:
              azureSubscription: 'Azure Subscription'
              scriptType: 'bash'
              scriptLocation: 'inlineScript'
              inlineScript: |
                # Convertir le .pfx en base64
                PFX_BASE64=$(base64 -w 0 $(Pipeline.Workspace)/certificates/weatherforecast-dataprotection.pfx)
                THUMBPRINT=$(cat $(Pipeline.Workspace)/certificates/thumbprint.txt)
                
                # Stocker dans Key Vault
                az keyvault secret set \
                  --vault-name weatherforecast-kv \
                  --name dataprotection-cert-pfx \
                  --value "$PFX_BASE64"
                
                az keyvault secret set \
                  --vault-name weatherforecast-kv \
                  --name dataprotection-cert-thumbprint \
                  --value "$THUMBPRINT"
                
                echo "‚úÖ Certificat sauvegard√© dans Azure Key Vault"
